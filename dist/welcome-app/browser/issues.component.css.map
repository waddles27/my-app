{
  "version": 3,
  "sources": ["src/app/layout/issues/issues.component.scss", "node_modules/@angular/material/core/tokens/_token-utils.scss"],
  "sourcesContent": ["@use '@angular/material' as mat;\n\n:host {\n    display: grid;\n    height: 100%;\n    grid-template-rows: min-content 1fr;\n    grid-row-gap: 16px;\n    overflow: hidden;\n\n    @include mat.list-overrides((\n        list-item-leading-avatar-shape: var(--mat-sys-corner-small),\n    ));\n}\n\n.toolbar {\n    @include mat.form-field-overrides((\n        outlined-container-shape: var(--mat-sys-corner-extra-large),\n        outlined-outline-width: 0,\n        outlined-focus-outline-width: 0,\n        container-vertical-padding: 8px,\n        container-height: 40px\n    ));\n\n    display: grid;\n    grid-template-columns: 1fr;\n    grid-auto-flow: column;\n    grid-auto-columns: max-content;\n    grid-column-gap: 16px;\n    align-items: center;\n}\n\n.search {\n    position: relative;\n    isolation: isolate;\n    overflow: hidden;\n\n    border-radius: var(--mat-sys-corner-extra-large);\n    background-color: var(--mat-sys-surface-container-high);\n\n    &:hover {\n        --_state-layer-opacity: var(--mat-sys-hover-state-layer-opacity);\n    }\n\n    &::after {\n        content: '';\n        position: absolute;\n        inset: 0;\n        z-index: -1;\n        background-color: currentColor;\n        border-radius: inherit;\n        transition: opacity 150ms linear;\n\n        opacity: var(--_state-layer-opacity, 0);\n    }\n\n    &__prefix {\n        margin-left: 4px;\n    }\n\n    &__suffix {\n        margin-right: 8px;\n    }\n}\n\n.container {\n    display: grid;\n    height: 100%;\n    grid-auto-rows: min-content;\n    overflow: hidden;\n\n    border-radius: var(--mat-sys-corner-large);\n    background-color: var(--mat-sys-surface-container);\n}\n\n.heading {\n    display: grid;\n    grid-template-columns: 1fr;\n    grid-auto-flow: column;\n    grid-column-gap: 4px;\n\n    padding: 8px 16px;\n\n    background-color: var(--mat-sys-surface-container-high);\n}\n\n.content {\n    position: relative;\n    padding-block: 8px;\n}\n\n.progress {\n    position: absolute;\n    inset-inline: 0;\n    top: 0;\n}\n", "@use '../style/elevation';\n@use '../style/sass-utils';\n@use './m3-system';\n@use 'sass:list';\n@use 'sass:map';\n@use 'sass:string';\n\n$_tokens: null;\n$_component-prefix: null;\n$_system-fallbacks: m3-system.create-system-fallbacks();\n\n// Sets the token prefix and map to use when creating token slots.\n@mixin use-tokens($prefix, $tokens) {\n  $_component-prefix: $prefix !global;\n  $_tokens: $tokens !global;\n\n  @content;\n\n  $_component-prefix: null !global;\n  $_tokens: null !global;\n}\n\n// Combines a prefix and a string to generate a CSS variable name for a token.\n@function _create-var-name($prefix, $token) {\n  @if $prefix == null or $token == null {\n    @error 'Must specify both prefix and name when generating token';\n  }\n\n  $string-prefix: '';\n\n  // Prefixes are lists so we need to combine them.\n  @each $part in $prefix {\n    $string-prefix: if($string-prefix == '', $part, '#{$string-prefix}-#{$part}');\n  }\n\n  @return string.unquote('--#{$string-prefix}-#{$token}');\n}\n\n// Creates a CSS variable, including the fallback if provided.\n@function _create-var($name, $fallback: null) {\n  @if ($fallback) {\n    @return var($name, $fallback);\n  } @else {\n    @return var($name);\n  }\n}\n\n// Gets the value of the token given the current global context state.\n@function _get-token-value($token, $fallback) {\n  $var-name: _create-var-name($_component-prefix, $token);\n  $fallback: _get-token-fallback($token, $fallback);\n  @return _create-var($var-name, $fallback);\n}\n\n// Assertion mixin that throws an error if the global state has not been set up by wrapping\n// calls with `use-tokens`.\n@function _assert-use-tokens($token) {\n  @if $_component-prefix == null or $_tokens == null {\n    @error 'Function was not called within a wrapping call of `use-tokens`';\n  }\n  @if not map.has-key($_tokens, $token) {\n    @error 'Token #{$token} does not exist. Configured tokens are: #{map.keys($_tokens)}';\n  }\n\n  @return true;\n}\n\n// Emits a slot for the given token, provided that it has a non-null value in the token map passed\n// to `use-tokens`.\n// Accepts an optional fallback parameter to include in the CSS variable.\n// If $fallback is `true`, then use the tokens map to get the fallback.\n// TODO: Remove the use case where we accept \"true\" and handle any failing client screenshots\n@mixin create-token-slot($property, $token, $fallback: null) {\n  $_assert: _assert-use-tokens($token);\n  @if map.get($_tokens, $token) != null {\n    #{$property}: #{_get-token-value($token, $fallback)};\n  }\n}\n\n// Returns the name of a token including the current prefix. Intended to be used in calculations\n// involving tokens. `create-token-slot` should be used when outputting tokens.\n@function get-token-variable-name($token) {\n  $_assert: _assert-use-tokens($token);\n  @return _create-var-name($_component-prefix, $token);\n}\n\n// Returns a `var()` reference to a specific token. Intended for declarations\n// where the token has to be referenced as a part of a larger expression.\n// Accepts an optional fallback parameter to include in the CSS variable.\n// If $fallback is `true`, then use the tokens map to get the fallback.\n// TODO: Remove the use case where we accept \"true\" and handle any failing client screenshots\n@function get-token-variable($token, $fallback: null) {\n  $_assert: _assert-use-tokens($token);\n  @return _get-token-value($token, $fallback);\n}\n\n// Gets the token's fallback value. Prefers adding a system-level fallback if one exists, otherwise\n// use the provided fallback.\n@function _get-token-fallback($token, $fallback: null) {\n  // If the $fallback is `true`, this is the component's signal to use the current token map value\n  @if ($fallback == true) {\n    $fallback: map.get($_tokens, $token);\n  }\n\n  // Check whether there's a system-level fallback. If not, return the optional\n  // provided fallback (otherwise null).\n  $sys-fallback: map.get($_system-fallbacks, $_component-prefix, $token);\n  @if (not $sys-fallback) {\n    @return $fallback;\n  }\n\n  @if (sass-utils.is-css-var-name($sys-fallback)) {\n    @return _create-var($sys-fallback, $fallback);\n  }\n\n  @return $sys-fallback;\n}\n\n// Outputs a map of tokens under a specific prefix.\n@mixin create-token-values($prefix, $tokens) {\n  @if $tokens != null {\n    // TODO: The `&` adds to the file size of theme, but it's necessary for compatibility\n    // with https://sass-lang.com/documentation/breaking-changes/mixed-decls/. We should\n    // figure out a better way to do this or move all the concrete styles out of the theme.\n    & {\n      @each $key, $value in $tokens {\n        @if $value != null {\n          #{_create-var-name($prefix, $key)}: #{$value};\n        }\n      }\n    }\n  }\n}\n\n// MDC doesn't currently handle elevation tokens properly. As a temporary workaround we can combine\n// the elevation and shadow-color tokens into a full box-shadow and use it as the value for the\n// elevation token.\n@function resolve-elevation($tokens, $elevation-token, $shadow-color-token) {\n  $elevation: map.get($tokens, $elevation-token);\n  $shadow-color: map.get($tokens, $shadow-color-token);\n  @return map.merge(\n    $tokens,\n    (\n      $elevation-token: elevation.get-box-shadow($elevation, $shadow-color),\n      $shadow-color-token: null,\n    )\n  );\n}\n\n/// Checks whether a list starts wih a given prefix\n/// @param {List} $list The list value to check the prefix of.\n/// @param {List} $prefix The prefix to check.\n/// @return {Boolean} Whether the list starts with the prefix.\n@function _is-prefix($list, $prefix) {\n  @for $i from 1 through list.length($prefix) {\n    @if list.nth($list, $i) != list.nth($prefix, $i) {\n      @return false;\n    }\n  }\n  @return true;\n}\n\n/// Gets the supported color variants in the given token set for the given prefix.\n/// @param {Map} $tokens The full token map.\n/// @param {List} $prefix The component prefix to get color variants for.\n/// @return {List} The supported color variants.\n@function _supported-color-variants($tokens, $prefix) {\n  $result: ();\n  @each $namespace in map.keys($tokens) {\n    @if list.length($prefix) == list.length($namespace) - 1 and _is-prefix($namespace, $prefix) {\n      $result: list.append($result, list.nth($namespace, list.length($namespace)), comma);\n    }\n  }\n  @return $result;\n}\n\n/// Gets the token values for the given components prefix with the given options.\n/// @param {Map} $tokens The full token map.\n/// @param {List} $prefix The component prefix to get the token values for.\n/// @param {ArgList} Any additional options\n///   Currently the additional supported options are:\n//     - $color-variant - The color variant to use for the component\n//     - $emit-overrides-only - Whether to emit *only* the overrides for the\n//                              specific color variant, or all color styles. Defaults to false.\n/// @throws If given options are invalid\n/// @return {Map} The token values for the requested component.\n@function get-tokens-for($tokens, $prefix, $options...) {\n  $options: sass-utils.validate-keyword-args($options, (color-variant, emit-overrides-only));\n  @if $tokens == () {\n    @return ();\n  }\n  $values: map.get($tokens, $prefix);\n  $color-variant: map.get($options, color-variant);\n  $emit-overrides-only: map.get($options, emit-overrides-only);\n  @if $color-variant == null {\n    @return $values;\n  }\n  $overrides: map.get($tokens, list.append($prefix, $color-variant));\n  @if $overrides == null {\n    $variants: _supported-color-variants($tokens, $prefix);\n    $secondary-message: if(\n      $variants == (),\n      'Mixin does not support color variants',\n      'Supported color variants are: #{$variants}'\n    );\n\n    @error 'Invalid color variant: #{$color-variant}. #{$secondary-message}.';\n  }\n  @return if($emit-overrides-only, $overrides, map.merge($values, $overrides));\n}\n\n/// Emits new token values for the given token overrides.\n/// Verifies that the overrides passed in are valid tokens.\n/// New token values are emitted under the current selector or root.\n@mixin batch-create-token-values($overrides: (), $namespace-configs...) {\n  @include sass-utils.current-selector-or-root() {\n    $prefixed-name-data: ();\n    $unprefixed-name-data: ();\n    $all-names: ();\n\n    @each $config in $namespace-configs {\n      $namespace: map.get($config, namespace);\n      $prefix: if(map.has-key($config, prefix), map.get($config, prefix), '');\n      $tokens: _filter-nulls(map.get($config, tokens));\n      @each $name, $value in $tokens {\n        $prefixed-name: $prefix + $name;\n        $all-names: list.append($all-names, $prefixed-name, $separator: comma);\n        @if map.has-key($prefixed-name-data, $prefixed-name) {\n          @error #{\n          'Error overriding token: Ambiguous token name `'\n        }#{\n          $prefixed-name\n        }#{\n          '` exists in multiple namespaces: `('\n        }#{\n          list.nth(map.get($prefixed-name-data, $prefixed-name), 1)\n        }#{\n          ')` and `('\n        }#{\n          $namespace\n        }#{\n          ')`'\n        };\n        }\n        $prefixed-name-data: map.set($prefixed-name-data, $prefixed-name, ($namespace, $name));\n        $unprefixed-data: map.has-key($unprefixed-name-data, $name) and\n          map.get($unprefixed-name-data, $name) or\n          ();\n        $unprefixed-data: list.append($unprefixed-data, ($namespace, $prefixed-name));\n        $unprefixed-name-data: map.set($unprefixed-name-data, $name, $unprefixed-data);\n      }\n    }\n\n    @each $name, $value in $overrides {\n      @if map.has-key($prefixed-name-data, $name) {\n        $data: map.get($prefixed-name-data, $name);\n        $namespace: list.nth($data, 1);\n        $name: list.nth($data, 2);\n        @include create-token-values(\n          $namespace,\n          (\n            $name: $value,\n          )\n        );\n      } @else if (map.has-key($unprefixed-name-data, $name)) {\n        $datalist: map.get($unprefixed-name-data, $name);\n        $prefixed-names: ();\n        @each $data in $datalist {\n          $namespace: list.nth($data, 1);\n          $prefixed-names: list.append($prefixed-names, list.nth($data, 2), $separator: comma);\n          @include create-token-values(\n            $namespace,\n            (\n              $name: $value,\n            )\n          );\n        }\n        @warn #{\n        'Token `'\n      }#{\n        $name\n      }#{\n        '` is deprecated. Please use one of the following alternatives: '\n      }#{\n        $prefixed-names\n      };\n      } @else {\n        @error #{'Invalid token name `'}#{$name}#{'`. '}#{'Valid tokens are: '}#{$all-names};\n      }\n    }\n  }\n}\n\n/// Filters keys with a null value out of the map.\n/// @param {Map} $map The map to filter.\n/// @return {Map} The given map with all of the null keys filtered out.\n@function _filter-nulls($map) {\n  $result: ();\n  @each $key, $val in $map {\n    @if $val != null {\n      $result: map.set($result, $key, $val);\n    }\n  }\n  @return $result;\n}\n"],
  "mappings": ";AAEA;AACI,WAAA;AACA,UAAA;AACA,sBAAA,YAAA;AACA,gBAAA;AACA,YAAA;;ACqHA;AAGM,6CAAA,IAAA;;ADjHV,CAAA;AASI,WAAA;AACA,yBAAA;AACA,kBAAA;AACA,qBAAA;AACA,mBAAA;AACA,eAAA;;ACgGA,CD9GJ;ACiHU,6CAAA,IAAA;;AAHN,CD9GJ;ACiHU,2CAAA;;AAHN,CD9GJ;ACiHU,iDAAA;;AAHN,CD9GJ;ACiHU,+CAAA;;AAHN,CD9GJ;ACiHU,qCAAA;;ADhGV,CAAA;AACI,YAAA;AACA,aAAA;AACA,YAAA;AAEA,iBAAA,IAAA;AACA,oBAAA,IAAA;;AAEA,CARJ,MAQI;AACI,0BAAA,IAAA;;AAGJ,CAZJ,MAYI;AACI,WAAA;AACA,YAAA;AACA,SAAA;AACA,WAAA;AACA,oBAAA;AACA,iBAAA;AACA,cAAA,QAAA,MAAA;AAEA,WAAA,IAAA,sBAAA,EAAA;;AAGJ,CAAA;AACI,eAAA;;AAGJ,CAAA;AACI,gBAAA;;AAIR,CAAA;AACI,WAAA;AACA,UAAA;AACA,kBAAA;AACA,YAAA;AAEA,iBAAA,IAAA;AACA,oBAAA,IAAA;;AAGJ,CAAA;AACI,WAAA;AACA,yBAAA;AACA,kBAAA;AACA,mBAAA;AAEA,WAAA,IAAA;AAEA,oBAAA,IAAA;;AAGJ,CAAA;AACI,YAAA;AACA,iBAAA;;AAGJ,CAAA;AACI,YAAA;AACA,gBAAA;AACA,OAAA;;",
  "names": []
}
